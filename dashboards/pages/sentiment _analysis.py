import json
from pathlib import Path

import numpy as np
import pandas as pd
import streamlit as st
import plotly.express as px

st.set_page_config(page_title="Sentiment Analysis (JSON)", layout="wide")

# ---------- Subtle Palestinian-flag palette (muted) ----------
PALETTE = {
    "green": "#0B6E4F",   # muted green
    "red":   "#A23B3B",   # muted red
    "black": "#1F1F1F",   # soft black
    "white": "#F2F2F2",   # off-white
    "gray":  "#6B7280",   # slate-ish
}
SENT_COLORS = {"positive": PALETTE["green"], "negative": PALETTE["red"], "neutral": PALETTE["gray"]}

def subtle_plotly_theme(fig):
    fig.update_layout(
        paper_bgcolor=PALETTE["white"],
        plot_bgcolor=PALETTE["white"],
        font=dict(color=PALETTE["black"]),
        title_font=dict(color=PALETTE["black"]),
        legend=dict(
    title=dict(text="sentiment", font=dict(color=PALETTE["black"])),  # ðŸ‘ˆ ADD THIS
    bgcolor=PALETTE["white"],
    font=dict(color=PALETTE["black"])
)
,
        margin=dict(l=10, r=10, t=45, b=10),
    )

    fig.update_xaxes(
        title_font=dict(color=PALETTE["black"]),
        tickfont=dict(color=PALETTE["black"]),
        gridcolor="rgba(0,0,0,0.08)",
        zerolinecolor="rgba(0,0,0,0.12)",
    )

    fig.update_yaxes(
        title_font=dict(color=PALETTE["black"]),
        tickfont=dict(color=PALETTE["black"]),
        gridcolor="rgba(0,0,0,0.08)",
        zerolinecolor="rgba(0,0,0,0.12)",
    )

    return fig



st.title("Analyzed Comments Dashboard")
st.caption("Source: JSON file generated by the pipeline (not MongoDB)")

# Path comes from secrets.toml, e.g. data/reddit_db.comments_analysed.json
data_path = Path(st.secrets["ANALYZED_COMMENTS_JSON"])

@st.cache_data
def load_analyzed_comments(path: Path) -> pd.DataFrame:
    raw = json.loads(path.read_text(encoding="utf-8"))
    df = pd.json_normalize(raw)  # flattens nested fields like sentiment_vivekn.label

    # Parse types safely
    if "created_at" in df.columns:
        df["created_at"] = pd.to_datetime(df["created_at"], errors="coerce")

    for col in ["score", "vader_confidence", "textblob_polarity", "textblob_subjectivity"]:
        if col in df.columns:
            df[col] = pd.to_numeric(df[col], errors="coerce")

    return df

if not data_path.exists():
    st.error(f"File not found: {data_path}")
    st.stop()

df = load_analyzed_comments(data_path)
if df.empty:
    st.warning("The JSON file is empty.")
    st.stop()

# ---------- Sidebar filters ----------
st.sidebar.header("Filters")

# Date filter
if "created_at" in df.columns and df["created_at"].notna().any():
    min_dt = df["created_at"].min()
    max_dt = df["created_at"].max()

    start, end = st.sidebar.date_input(
        "Date range",
        value=(min_dt.date(), max_dt.date()),
        min_value=min_dt.date(),
        max_value=max_dt.date(),
    )
    start_ts = pd.Timestamp(start)
    end_ts = pd.Timestamp(end) + pd.Timedelta(days=1) - pd.Timedelta(seconds=1)
    df_f = df[(df["created_at"] >= start_ts) & (df["created_at"] <= end_ts)].copy()
else:
    df_f = df.copy()
    st.sidebar.info("No valid `created_at` to filter by date.")

# Optional post_id filter
if "post_id" in df_f.columns:
    post_ids = sorted(df_f["post_id"].dropna().unique().tolist())
    selected_posts = st.sidebar.multiselect("Filter by post_id (optional)", post_ids, default=[])
    if selected_posts:
        df_f = df_f[df_f["post_id"].isin(selected_posts)].copy()

# ---------- Normalize labels ----------
def normalize_label(x):
    if pd.isna(x):
        return None
    x = str(x).strip().lower()
    if x in ["pos", "positive"]:
        return "positive"
    if x in ["neg", "negative"]:
        return "negative"
    if x in ["neu", "neutral"]:
        return "neutral"
    return x

if "vader_sentiment" in df_f.columns:
    df_f["vader_sentiment"] = df_f["vader_sentiment"].map(normalize_label)

vivekn_src = "sentiment_vivekn.label"
if vivekn_src in df_f.columns:
    df_f["vivekn_sentiment"] = df_f[vivekn_src].map(normalize_label)
else:
    df_f["vivekn_sentiment"] = None

# ---------- KPIs ----------
total = len(df_f)
avg_conf = float(df_f["vader_confidence"].mean()) if "vader_confidence" in df_f.columns else np.nan
avg_pol = float(df_f["textblob_polarity"].mean()) if "textblob_polarity" in df_f.columns else np.nan

agree_rate = np.nan
both = df_f.dropna(subset=["vader_sentiment", "vivekn_sentiment"]).copy()
if len(both) > 0:
    agree_rate = (both["vader_sentiment"] == both["vivekn_sentiment"]).mean() * 100

k1, k2, k3, k4 = st.columns(4)
k1.metric("Analyzed comments", f"{total:,}")
k2.metric("Avg VADER confidence", f"{avg_conf:.2f}" if not np.isnan(avg_conf) else "N/A")
k3.metric("Avg TextBlob polarity", f"{avg_pol:.3f}" if not np.isnan(avg_pol) else "N/A")
k4.metric("VADER â†” Vivekn agreement", f"{agree_rate:.1f}%" if not np.isnan(agree_rate) else "N/A")

st.divider()

# ---------- Visual 1: Sentiment distributions ----------
c1, c2 = st.columns(2)

with c1:
    st.subheader("VADER sentiment distribution")
    if "vader_sentiment" in df_f.columns and df_f["vader_sentiment"].notna().any():
        counts = (
            df_f["vader_sentiment"]
            .value_counts()
            .reindex(["positive", "neutral", "negative"])
            .dropna()
        )
        bar_df = counts.reset_index()
        bar_df.columns = ["sentiment", "count"]

        fig = px.bar(
            bar_df,
            x="sentiment",
            y="count",
            title="VADER",
            color="sentiment",
            color_discrete_map=SENT_COLORS,
        )
        fig = subtle_plotly_theme(fig)
        st.plotly_chart(fig, use_container_width=True)
    else:
        st.info("No VADER sentiment found.")

with c2:
    st.subheader("Vivekn sentiment distribution")
    if df_f["vivekn_sentiment"].notna().any():
        counts = (
            df_f["vivekn_sentiment"]
            .value_counts()
            .reindex(["positive", "neutral", "negative"])
            .dropna()
        )
        bar_df = counts.reset_index()
        bar_df.columns = ["sentiment", "count"]

        fig = px.bar(
            bar_df,
            x="sentiment",
            y="count",
            title="Vivekn (spark-nlp)",
            color="sentiment",
            color_discrete_map=SENT_COLORS,
        )
        fig = subtle_plotly_theme(fig)
        st.plotly_chart(fig, use_container_width=True)
    else:
        st.info("No Vivekn sentiment found in `sentiment_vivekn.label`.")

st.divider()

# ---------- Visual 2: Agreement matrix ----------
st.subheader("How often do models agree?")
both = df_f.dropna(subset=["vader_sentiment", "vivekn_sentiment"]).copy()
if len(both) >= 5:
    mat = pd.crosstab(both["vader_sentiment"], both["vivekn_sentiment"])
    order = ["positive", "neutral", "negative"]
    mat = mat.reindex(index=order, columns=order).fillna(0).astype(int)

    fig = px.imshow(
        mat,
        text_auto=True,
        aspect="auto",
        title="Agreement matrix (rows = VADER, cols = Vivekn)",
        color_continuous_scale=[[0, PALETTE["white"]], [1, PALETTE["black"]]],
    )
    fig = subtle_plotly_theme(fig)
    st.plotly_chart(fig, use_container_width=True)
else:
    st.info("Not enough rows with both VADER and Vivekn labels to compute agreement.")

st.divider()

# ---------- Visual 3: TextBlob scatter ----------
st.subheader("TextBlob: polarity vs subjectivity")
if {"textblob_polarity", "textblob_subjectivity"}.issubset(df_f.columns):
    tmp = df_f.dropna(subset=["textblob_polarity", "textblob_subjectivity"]).copy()
    if len(tmp) > 0:
        color_col = "vader_sentiment" if tmp["vader_sentiment"].notna().any() else None
        fig = px.scatter(
            tmp,
            x="textblob_polarity",
            y="textblob_subjectivity",
            color=color_col,
            color_discrete_map=SENT_COLORS,
            hover_data=[c for c in ["post_id", "comment_id", "vader_confidence"] if c in tmp.columns],
            title="Polarity (negative â†’ positive) vs Subjectivity (factual â†’ opinionated)",
        )
        fig = subtle_plotly_theme(fig)
        st.plotly_chart(fig, use_container_width=True)
    else:
        st.info("No TextBlob polarity/subjectivity values to plot.")
else:
    st.info("TextBlob fields not found in the JSON.")

st.divider()

# ---------- Visual 4: Sentiment over time (VADER) ----------
st.subheader("Sentiment over time (VADER)")
if "created_at" in df_f.columns and df_f["created_at"].notna().any() and df_f["vader_sentiment"].notna().any():
    freq = st.selectbox("Time granularity", ["Hour", "Day"], index=1)
    rule = "H" if freq == "Hour" else "D"

    tmp = df_f.dropna(subset=["created_at", "vader_sentiment"]).copy()
    tmp["bucket"] = tmp["created_at"].dt.floor(rule)

    ts = tmp.groupby(["bucket", "vader_sentiment"]).size().reset_index(name="count")
    ts = ts[ts["vader_sentiment"].isin(["positive", "neutral", "negative"])]

    fig = px.area(
        ts,
        x="bucket",
        y="count",
        color="vader_sentiment",
        color_discrete_map=SENT_COLORS,
        title=f"VADER sentiment volume per {freq.lower()}",
    )
    fig = subtle_plotly_theme(fig)
    st.plotly_chart(fig, use_container_width=True)
else:
    st.info("Need valid `created_at` and `vader_sentiment` to plot sentiment over time.")

st.divider()

# ---------- Table: top confident predictions ----------
st.subheader("Most confident VADER predictions (sample)")

if "vader_confidence" in df_f.columns and df_f["vader_confidence"].notna().any():
    top = df_f.sort_values("vader_confidence", ascending=False).head(10).copy()
else:
    top = df_f.head(10).copy()

if "text" in top.columns:
    top["text_preview"] = top["text"].fillna("").astype(str).str.slice(0, 180) + "â€¦"

cols = [c for c in ["post_id", "comment_id", "vader_sentiment", "vader_confidence", "vivekn_sentiment", "text_preview", "created_at"] if c in top.columns]
st.dataframe(top[cols], use_container_width=True, hide_index=True)
